---
converter: markdown
metadata:
  title: Cache 
  description: Detailed descriptions of page, action, and fragment caching with examples.  
slug: tutorials/performance/cache
searchable: true
---

## Page caching

Page caching means you create a static HTML site, and serve it bypassing the whole server side, including authorization. It's super fast, but you can rarely use it. For example, it's great to use this for the home page, to make it very fast for non-authenticated users, but you can't do the same for a dashboard, because the user has to be authenticated. 

**Example:** 

```liquid
{% raw %}
cache_static_page_for: 0 
{% endraw %}
```
{% include 'alert/note', content: 'In the old infrastructure of PlatformOS, you used `cache_for`, in the new infrastructure you should use `cache_static_page_for`.' %}
 
## Action caching

Action caching works similarly to page caching, you can use it to cache the whole page, but the difference is that it triggers authorization, so it works also for logged in users.  

**Example:** 

```liquid
{% raw %}
cache_expiration_key > 
	{{ context.page.slug }} 
cache_action_for: 10 
cache_layout: true 
{% endraw %}
```

**Explanation:** 

There are three properties that control the action cache: 

* The **`cache_expiration_key`** allows you to define a unique identifier for the page. By default, it's the full page URL. If you cache a page for 10 seconds, and the `cache_expiration_key` is blank, cache will be generated for the whole URL. If the user changes anything in the URL, the cache will not be taken into consideration. 

   In a scenario, where you have multiple product pages, and you want to cache the product page, you can have a GraphQL query here: 
   
   ```liquid
   {% raw %}
   cache_expiration_key > 
	   {% graph_query 'get_cached_at_from_product', result_name: 'g' %} 
	   {{ context.page.slug }}/{{ g.results.first.cached_at }}
   cache_action_for: 0 
   cache_layout: true 
   {% endraw %}
   ```

* The default for `cache_action_for` is as long as possible. Setting it to `0` means invalidate the cache if anything changes (i.e. when the `cache_expiration_key` changes).  
* The default for `cache_layout` is `false`. 

## Fragment caching

Using page caching, or action caching for the whole page, whenever you change something on the page and deploy it, the cache will be invalidated. In reality, it's rare, that you would want to cache the whole page or layout (this is why `cache_layout` is `false` by default). 

You can cache specific parts of a page or layout using fragment caching, where you just cache common parts, fragments that take a lot of time and can be cached, for example:

```liquid
{% raw %}
{% assign cache_key = context.page.slug %}
{% cache cache_key, expires_in: 5 %}
   {% include 'very_big_graph_query' %}
   {% for ... %}
      ...
   {% endfor %}
{% endcache %}
{% endraw %}
```

## Testing the cache 

You can test the cache by adding a random string to the beginning of the page and another one to the beginning of the layout. This way, you can see if the string on the page or layout has changed after refreshing the page:

* When the page is rendered from the cache, the string remains the same. 
* When the cache is invalidated (e.g. after the time specified in the `cache_action_for` property), the string changes.  

**Example:**

```liquid
{% raw %}
randomstring: {{ 18 | random_string }} 
{% endraw %}
```

## Tokens

Caching pages that include secret tokens (like an `authenticity_token` that's generated for each session) can be implemented using fragment caching. 

If you cache the whole page that includes a token, then the token gets also cached. This could for example prevent the user from submitting a form. 

PlatformOS automatically processes the cache and updates those tokens if you use the PlatformOS-specific `form` tag. 
If you'd like to use the `form` HTML tag, you have to include the token exactly as it is. 
If you're using JavaScript, we include the CSRF token in the cookie of the logged in user. 

{% include 'shared/questions_section' %}

 


